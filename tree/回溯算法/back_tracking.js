/**
 * 回溯算法
 * 
 * 回溯算法，又称为“试探法”。解决问题时，每进行一步，都是抱着试试看的态度，如果发现当前选择并不是最好的，或者这么走下去肯定达不到目标，立刻做回退操作重新选择。
 * 这种走不通就回退再走的方法就是回溯算法。
 */

// 例如，在解决列举集合 {1,3,5,7,9} 中所有子集的问题中，就可以使用回溯算法。从集合的开头元素开始，对每个元素都有两种选择：取还是舍。
// 当确定了一个元素的取舍之后，再进行下一个元素，直到集合最后一个元素。其中的每个操作都可以看作是一次尝试，每次尝试都可以得出一个结果。将得到的结果综合起来，就是集合的所有子集。

let arr = [1,3,5,7,9]; // 数组（模拟的集合）
let len = arr.length+1; // 新建集合长度，len多加一个1，正好将索引0的位置空出来，使索引 1、2、3、...、len 对应集合中的对应元素
let set = new Array(len); // 设置一个数组（模拟的集合），数组的下标表示集合中的元素，所以从arr数组取数据的时候，只用下标为 1，2，3，...，len 的空间

function main() {
    for (let i = 0; i < len; i++) {
        set[i] = 0;
    }
    console.log(`set init: ${set}`);
    PowerSet(1, arr.length);
}

// i代表数组下标，n表示集合的长度
function PowerSet(i, n) {
    //当i>n时，说明集合中所有的元素都做了选择，开始判断
    if (i > n) {
        let child_set = [];
        for (let j = 1; j <= n; j++) {
            //如果树组中存放的是 1，说明在当初尝试时，选择取该元素，即对应的数组下标，所以，可以输出
            if (set[j] == 1) {
                child_set.push(arr[j-1]);
            }
        }
        console.log(set, child_set);
        console.log('\r\n');
    } else {
        // 如果选择要该元素，对应的数组单元中赋值为1；反之，赋值为0。然后继续向下探索。
        set[i] = 1; 
        PowerSet(i + 1, n);
        set[i] = 0; 
        PowerSet(i + 1, n);
    }
}

main();