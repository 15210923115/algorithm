// 起泡排序，别名“冒泡排序”，该算法的核心思想是将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列。
// 通过一趟趟的比较，一个个的“最大值”被找到并移动到相应位置，直到检测到表中数据已经有序，或者比较次数等同于表中含有记录的个数，排序结束，这就是起泡排序。

let arr = [38, 49, 65, 76, 13, 27, 49, 97];

let bubble = (arr) => {

    let temp;
    for (let i = 0; i<arr.length - 1; i++) {// 最后一个数，就剩自己了，不需要比较，所以减1
        for (let j = 0; j<arr.length - i -1; j++) {// 已经排好序的，不需要再跟它进行比较，所以减i
            // 升序
            if (arr[j] > arr[j+1]) {
                temp = arr[j+1];
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }

    console.log(arr);
};

bubble(arr);

/**
 * 总结：
    使用起泡排序算法，其时间复杂度同实际表中数据的无序程度有关。
    若表中记录本身为正序存放，则整个排序过程只需进行 n-1（n 为表中记录的个数）次比较，且不需要移动记录；
    若表中记录为逆序存放（最坏的情况），则需要 n-1趟排序，进行 n(n-1)/2 次比较和数据的移动。所以该算法的时间复杂度为O(n^2)。
 */

 /**
  * 时间复杂度：
    若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 和记录移动次数 均达到最小值： 
    C(min) = n-1, M(min) = 0;
    所以，冒泡排序最好的时间复杂度为O(n)。
    
    若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。
    在这种情况下，比较和移动次数均达到最大值： 
    C(max) = n(n-1)/2 = O(n^2)
    M(max) = 3n(n-1)/2 = O(n^2)

    冒泡排序的最坏时间复杂度为O(n^2)
    综上，因此冒泡排序总的平均时间复杂度为O(n^2)

    算法稳定性：
    冒泡排序就是把小的元素``往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
    所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，
    这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
  */